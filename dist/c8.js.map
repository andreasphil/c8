{
  "version": 3,
  "sources": ["../src/c8.js"],
  "sourcesContent": ["/* -------------------------------------------------- *\n * Types                                              *\n * -------------------------------------------------- */\n\n/**\n * @template T\n * @typedef {object} AttrDefinition\n * @prop {(val: string | null) => T} [parse]\n * @prop {(val: T) => string} [stringify]\n * @prop {() => string} [default]\n */\n\n/**\n * @template T\n * @typedef {{ [K in keyof T]: AttrDefinition<T[K]> }} Attrs\n */\n\n/* -------------------------------------------------- *\n * Utils                                              *\n * -------------------------------------------------- */\n\n/**\n * @template T\n * @param {AttrDefinition<T>} definition\n * @returns {AttrDefinition<T>}\n */\nexport function defineAttr(definition) {\n  return definition;\n}\n\n/**\n * @param {TemplateStringsArray} strings\n * @param {unknown[]} values\n * @returns {string}\n */\nconst tag = (strings, ...values) => String.raw({ raw: strings }, ...values);\n\n/**\n * Helper for HTML template strings. The tag does nothing, but using it will\n * allow syntax highlighting and formatting if your editor supports it.\n */\nexport const html = tag;\n\n/**\n * Helper for CSS template strings. The tag does nothing, but using it will\n * allow syntax highlighting and formatting if your editor supports it.\n */\nexport const css = tag;\n\n/**\n * @param {string} template\n * @returns {Node}\n */\nexport function renderTemplate(template) {\n  const templateEl = document.createElement(\"template\");\n  templateEl.innerHTML = template;\n  return templateEl.content.cloneNode(true);\n}\n\n/* -------------------------------------------------- *\n * Component base class                               *\n * -------------------------------------------------- */\n\n/**\n * @template {Record<string, any>} Attrs\n * @template {Record<string, Element>} Refs\n * @template {Record<string, any>} Emits\n */\nexport class C8 extends HTMLElement {\n  /**\n   * Tag under which the component will be available after registering. Must be\n   * set and must be a valid custom element name.\n   *\n   * @type {string}\n   */\n  static tag = \"\";\n\n  /**\n   * Observed attributes of the component. The information in this property\n   * will be used to populate the instance's `attrs` property with the actual\n   * values of the attributes, and sync changes to the values back to the\n   * HTML.\n   *\n   * @type {Record<string, AttrDefinition<unknown>>}\n   */\n  static attrs = {};\n\n  /**\n   * The names of events that will automatically be listened to. This should\n   * return all event types that you intend to register via `data-on:<type>`\n   * attributes.\n   *\n   * @type {Array<keyof WindowEventMap | string>}\n   * @default []\n   */\n  static events = [];\n\n  /**\n   * Registers the component as a custom element. For compatibility, you can\n   * provide a tag name, otherwise the tag name will default to the value of\n   * `this.tag`.\n   *\n   * @param {string} [tag]\n   */\n  static define(tag = this.tag) {\n    if (!tag) throw new Error(\"Custom element must specify a tag name\");\n\n    customElements.define(tag, this);\n  }\n\n  /**\n   * Returns the attributes for which the component will be notified of\n   * changes. Note that this is intended to be used by the browser. You\n   * should describe the attributes you expect via `this.attrs` and\n   * usually won't need to touch this function.\n   *\n   * @returns {string[]}\n   */\n  static get observedAttributes() {\n    return Object.keys(this.attrs);\n  }\n\n  /**\n   * The component's stylesheet. This will be added to the shadow DOM's adopted\n   * stylesheets on initialization. Must be `undefined` if shadow DOM is disabled,\n   * otherwise an exception is thrown.\n   *\n   * @type {string | undefined}\n   * @default undefined\n   */\n  get styles() {\n    return undefined;\n  }\n\n  /**\n   * The component's template. This will be inserted into the custom element on\n   * initialization.\n   *\n   * @type {string}\n   */\n  get template() {\n    throw new Error(\"Custom element must specify a template\");\n  }\n\n  /**\n   * Reflected attributes. This will be populated automatically based on the\n   * attributes specified in the element's static `attrs` property.\n   *\n   * @type {Attrs}\n   */\n  attrs;\n\n  /**\n   * @type {ShadowRoot | this}\n   */\n  get #root() {\n    return this.shadowRoot ?? this;\n  }\n\n  constructor() {\n    super();\n\n    try {\n      this.attachShadow({ mode: \"open\" });\n    } catch {\n      // Shadow root has been disabled. Ignore; light DOM will be used\n      // automatically instead.\n    }\n  }\n\n  connectedCallback() {\n    this.#insertTemplate();\n    this.#adoptCss();\n    this.#registerAttributes();\n    this.#attachEvents();\n  }\n\n  /**\n   * Returns the element with that ref name. This will throw if no ref with\n   * that name was found.\n   *\n   * @template {keyof Refs} T\n   * @param {T} name\n   * @returns {Refs[T]}\n   */\n  ref(name) {\n    const el = this.maybeRef(name);\n    if (!el) throw new Error(`Ref with name ${String(name)} was not found`);\n    return el;\n  }\n\n  /**\n   * Returns the element with that ref name, or `undefined` if no ref with\n   * that name was found.\n   *\n   * @template {keyof Refs} T\n   * @param {T} name\n   * @returns {Refs[T]}\n   */\n  maybeRef(name) {\n    const el = this.#root.querySelector(`[data-ref=\"${String(name)}\"]`);\n\n    // @ts-expect-error Can't be sure, need to trust the user's typings\n    return el ?? undefined;\n  }\n\n  /**\n   * Returns all elements that are marked as refs.\n   *\n   * @returns {Partial<Refs>}\n   */\n  refs() {\n    const els = {};\n\n    this.#root.querySelectorAll(\"[data-ref]\").forEach((el) => {\n      if (el instanceof HTMLElement && el.dataset.ref) els[el.dataset.ref] = el;\n    });\n\n    return els;\n  }\n\n  /**\n   * Emits an event with the specified payload.\n   *\n   * @template {keyof Emits} T\n   * @param {T} name\n   * @param {Emits[T]} payload\n   */\n  emit(name, payload) {\n    const event = new CustomEvent(String(name), {\n      bubbles: true,\n      cancelable: true,\n      composed: true,\n      detail: payload,\n    });\n\n    this.dispatchEvent(event);\n  }\n\n  #insertTemplate() {\n    if (this.template.startsWith(\"#\")) {\n      const templateEl = document.querySelector(this.template);\n      if (!(templateEl instanceof HTMLTemplateElement)) {\n        throw new Error(`${this.template} is not a template element`);\n      }\n      this.#root.appendChild(templateEl.content.cloneNode(true));\n    } else {\n      const templateNode = renderTemplate(this.template);\n      this.#root.appendChild(templateNode);\n    }\n  }\n\n  #adoptCss() {\n    if (!this.styles) return;\n\n    if (!(this.#root instanceof ShadowRoot)) {\n      throw new Error('CSS is not supported when \"shadow\" is disabled');\n    }\n\n    const styleSheet = new CSSStyleSheet();\n    styleSheet.replaceSync(this.styles);\n\n    this.#root.adoptedStyleSheets.push(styleSheet);\n  }\n\n  #attachEvents() {\n    /** @type {typeof C8} */\n    // @ts-expect-error\n    const { events } = this.constructor;\n\n    events.forEach((type) => {\n      this.#root.addEventListener(type, (event) => {\n        if (!(event.target instanceof HTMLElement)) return;\n\n        let target = event.target;\n        const handlerAttr = `on:${event.type}`;\n        const handlerSelector = `[data-${handlerAttr.replace(\":\", \"\\\\:\")}]`;\n\n        let handlerName = target.dataset[handlerAttr];\n        if (!handlerName && (target = target.closest(handlerSelector))) {\n          handlerName = target.dataset[handlerAttr];\n        }\n\n        this[handlerName]?.(event);\n      });\n    });\n  }\n\n  #registerAttributes() {\n    /** @type {typeof C8} */\n    // @ts-expect-error\n    const { attrs } = this.constructor;\n\n    // @ts-expect-error We'll populate the object below\n    this.attrs ??= {};\n\n    Object.entries(attrs).forEach(([name, def]) => {\n      const stringify = def.stringify ?? ((val) => val?.toString() ?? \"\");\n      const parse = def.parse ?? ((val) => val);\n\n      Object.defineProperty(this.attrs, name, {\n        get: () => parse(this.getAttribute(name)),\n        set: (val) => this.setAttribute(name, stringify(val)),\n      });\n\n      if (def.default && !this.getAttribute(name)) {\n        this.setAttribute(name, def.default());\n      }\n    });\n  }\n}\n"],
  "mappings": "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",
  "names": ["defineAttr", "definition", "tag", "strings", "values", "html", "css", "renderTemplate", "template", "templateEl", "C8", "#root", "#insertTemplate", "#adoptCss", "#registerAttributes", "#attachEvents", "name", "el", "els", "payload", "event", "templateNode", "styleSheet", "events", "type", "target", "handlerAttr", "handlerSelector", "handlerName", "attrs", "def", "stringify", "val", "parse"]
}
